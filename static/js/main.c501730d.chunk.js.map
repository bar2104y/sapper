{"version":3,"sources":["Components/mainmenu.js","Pannels/Home.js","Components/Playarea.js","App.js","serviceWorker.js","index.js"],"names":["Mainmenu","className","onClick","this","props","go","data-to","React","Component","Home","id","fetchedUser","Playarea","canvSize","window","innerWidth","lineWidth","areaSize","step","area","firstPress","score","openedMines","sec","min","areaOpen","i","j","getPosByIndex","bind","selectRect","genArea","isMine","isClear","getMinesInBlock","timer","winGame","filedGame","canvas","refs","ctx","getContext","addEventListener","createCanvas","setInterval","s","document","getElementById","innerHTML","e","clearInterval","x","fillStyle","fillRect","beginPath","moveTo","lineTo","strokeStyle","stroke","xPos","clientX","target","offsetLeft","yPos","clientY","offsetTop","xIndex","Math","floor","yIndex","openBlock","lastblock","y","nx","ny","a","random","push","length","f","splice","cnt","getMinesAround","font","textBaseline","fillText","ref","width","height","App","setState","activePanel","currentTarget","dataset","to","console","log","state","connect","send","subscribe","detail","type","data","publish","joinToGroup","Boolean","location","hostname","match","ReactDOM","render"],"mappings":"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","file":"static/js/main.c501730d.chunk.js","sourcesContent":["import React from 'react';\nimport '../Css/mainmenu.css'\n\nclass Mainmenu extends React.Component {\n    render(){\n        return(\n            <div className=\"mainMenuConatainer\">\n                <div className=\"actionButton\" onClick={this.props.go} data-to=\"play\"><p>Играть</p></div>\n                <div className=\"actionButton\" onClick={this.props.go} data-to=\"leaders\"><p>Лидеры</p></div>\n                <div className=\"actionButton\" onClick={this.props.go} data-to=\"share\"><p>Поделиться</p></div>\n            </div>\n        )\n    }\n}\n\nexport default Mainmenu","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { Panel, Group, PanelHeader, } from '@vkontakte/vkui';\nimport Mainmenu from '../Components/mainmenu'\n\n/*<Group title={fetchedUser.first_name+' '+fetchedUser.last_name}>\n\t\t</Group>\n\t\t*/\n\nconst Home = ({ id, go, fetchedUser }) => (\n\t<Panel id={id} >\n\t\t<PanelHeader>\n            Сапер\n        </PanelHeader>\n\t\t\n\t\t<Mainmenu go={go} />\n\t\t\n        \n        \n\t</Panel>\n);\n\nHome.propTypes = {\n\tid: PropTypes.string.isRequired,\n\tgo: PropTypes.func.isRequired,\n\tfetchedUser: PropTypes.shape({\n\t\tphoto_200: PropTypes.string,\n\t\tfirst_name: PropTypes.string,\n\t\tlast_name: PropTypes.string,\n\t\tcity: PropTypes.shape({\n\t\t\ttitle: PropTypes.string,\n\t\t}),\n\t}),\n};\n\nexport default Home;","import React from 'react';\nimport '../Css/game.css'\nimport { Panel, PanelHeader } from '@vkontakte/vkui';\n\n\n\n\nclass Playarea extends React.Component {\n    constructor (props){\n        super(props);\n\n        this.canvSize = window.innerWidth*0.9    //Размер холста px\n        this.lineWidth = 2                       //Толщина линии px\n        this.areaSize = 10                       //Кол-во ячеек в стороне\n        this.step = (this.canvSize-(2*this.lineWidth))/this.areaSize //Ширина и высота клетки\n        this.area = []                           // Массив мина/не мина\n        this.firstPress = true                   //Первый клик\n        this.score = this.areaSize*this.areaSize //Стартовое кол-во очков\n        this.openedMines = []                       //Открытые ячейки\n\n        this.sec = 0 //Время, секунды\n        this.min = 0 //Время, минуты\n\n        //Подготовка массива с открытыми ячейками\n        this.areaOpen = []\n        for (let i = 0; i<this.areaSize; i++){\n            this.areaOpen[i] = []\n            for ( let j = 0; j < this.areaSize; j++){\n                this.areaOpen[i][j] = 0\n            }\n        }\n\n        //Подключение функций (объясните мне зачем это вообще нужно)\n        this.getPosByIndex = this.getPosByIndex.bind(this)\n        this.selectRect = this.selectRect.bind(this)\n        this.genArea = this.genArea.bind(this)\n        this.isMine = this.isMine.bind(this)\n        this.isClear = this.isClear.bind(this)\n        this.getMinesInBlock = this.getMinesInBlock.bind(this)\n        this.timer = this.timer.bind(this)   \n        \n        this.winGame = this.winGame.bind(this)\n        this.filedGame = this.filedGame.bind(this)\n    }\n    componentDidMount(){\n        //иницианализация холста\n        this.canvas = this.refs.canvas\n        this.ctx = this.refs.canvas.getContext('2d')\n        // Прослушиваем событие клика\n        this.canvas.addEventListener('click', this.selectRect)\n        //Подготавливаем холст\n        this.createCanvas()\n\n        //Обновление секундомера\n        setInterval( this.timer, 1000)\n    }\n\n    //Секундомер\n    timer(){\n        this.sec++\n            if (this.sec == 60){\n                this.min++\n                this.sec = 0\n            }\n            let s = ''\n            if (this.min < 10) s += '0'\n            s += this.min + ':'\n            if (this.sec <10 ) s+= '0'\n            s+=this.sec\n\n            try{\n                document.getElementById('time').innerHTML = s\n            }\n            catch(e){\n                clearInterval(this.timer)\n            }\n    }\n\n    //Получение левого верзнего угла ячейки\n    getPosByIndex(x){\n        return(x*this.step+this.lineWidth)\n    }\n\n    //Создание заготовки игрового поля\n    createCanvas(){\n        //Заполнение фона\n        this.ctx.fillStyle=\"#9E9E9E\";\n        this.ctx.fillRect(0,0,this.canvSize,this.canvSize);\n\n        //Прорисовка линий\n        this.ctx.beginPath()\n        this.ctx.lineWidth = this.lineWidth\n\n        for(let i = this.lineWidth; i<=this.canvSize; i+=this.step ){\n            this.ctx.moveTo(0,i)\n            this.ctx.lineTo(this.canvSize,i)\n            this.ctx.moveTo(i,0)\n            this.ctx.lineTo(i,this.canvSize)\n        }\n\n        //Отображение изменений\n        this.ctx.strokeStyle=\"#333\"\n        this.ctx.stroke()\n\n    }\n\n    //При клике на поле\n    selectRect(e){\n\n        this.ctx.beginPath()\n        this.ctx.fillStyle=\"#5E5E5E\";\n        \n        //Получение координат клика\n        let xPos = e.clientX-e.target.offsetLeft\n        let yPos = e.clientY-e.target.offsetTop\n\n        //Определение ячейки\n        let xIndex = Math.floor(xPos/this.step)\n        let yIndex = Math.floor(yPos/this.step)\n\n        //Координаты левого верхнего угла ячейки\n        xPos = this.getPosByIndex(xIndex)\n        yPos = this.getPosByIndex(yIndex)\n        \n        //Определение первого клика\n        if (this.firstPress){\n            this.ctx.fillRect(xPos,yPos, this.step, this.step)\n            this.firstPress = false\n            this.genArea(xIndex,yIndex)\n            \n            this.areaOpen[xIndex][yIndex] = 2\n\n            this.openBlock(xIndex,yIndex)\n            /*this.ctx.fillStyle = 'whitesmoke'\n            this.ctx.font = \"bold \" + Math.floor(this.step/1.5) + \"pt sans-serif\"\n            this.ctx.textBaseline = \"center\"\n            this.ctx.fillText(this.getMinesAround(xIndex,yIndex),xPos+this.step/4,yPos+this.step/1.1)\n        */\n            this.lastblock= [xIndex+1,yIndex+1]\n        } else{\n            //отмена предыдущего выделения\n            if (this.areaOpen[this.lastblock[0]][this.lastblock[1]] < 2){\n                this.ctx.fillStyle=\"#9E9E9E\";\n                this.ctx.fillRect(this.getPosByIndex(this.lastblock[0]),\n                    this.getPosByIndex(this.lastblock[1]),\n                    this.step, this.step)\n            }\n\n            //Запомнить выбор\n            this.lastblock = [xIndex,yIndex]\n            \n            //выделение ячейки\n            if(this.areaOpen[xIndex][yIndex] < 2){\n                this.ctx.fillStyle=\"#7E7E7E\";\n                this.ctx.fillRect(xPos,yPos, this.step, this.step)\n            }\n            \n        }\n        \n        //перерисовка прямых, костыль\n        this.ctx.lineWidth = this.lineWidth/2\n        for(let i = this.lineWidth; i<=this.canvSize; i+=this.step ){\n            this.ctx.moveTo(0,i)\n            this.ctx.lineTo(this.canvSize,i)\n            this.ctx.moveTo(i,0)\n            this.ctx.lineTo(i,this.canvSize)\n        }\n        //Отображение изменений\n        this.ctx.stroke()\n    }\n\n    //Генерация мин\n    genArea(x,y){\n        //Инициализация массива\n        let a = []\n        for (let i = 0; i<this.areaSize; i++){\n            a[i] = []\n            for ( let j = 0; j < this.areaSize; j++){\n                a[i][j] = 0\n            }\n        }\n        \n\n        //Генерация мин\n        let nx,ny\n        let i = 0\n        while (i< this.areaSize){\n            nx = Math.floor(Math.random()*10)\n            ny = Math.floor(Math.random()*10)\n\n            if((nx != x || ny != y) && a[nx][ny] == 0){\n                a[nx][ny] = 1\n                i++\n            }\n        }\n        \n        //Запись в глобальную переменную\n        \n        this.area = a\n\n    }\n\n    //Клик на кнопку МИНА\n    isMine(){\n        \n        let xIndex = this.lastblock[0]\n        let yIndex = this.lastblock[1]\n        //Позиция курсора\n        let xPos = this.getPosByIndex( xIndex)\n        let yPos = this.getPosByIndex( yIndex)\n        //Заливка ячейки красным цветом\n        this.ctx.fillStyle=\"darkred\";\n        this.ctx.fillRect(xPos,yPos, this.step, this.step)\n        //Помечаем как предпологаемую мину\n        this.areaOpen[xIndex][yIndex] = 3\n        this.openedMines.push([xIndex,yIndex])\n        \n        \n        //Все ли мины подсвечены\n        if (this.openedMines.length == this.areaSize){\n            let f = true\n            //Все ли из подсвеченных верны\n            for (let i = 0; i< this.openedMines.length; i++){\n                if (this.area[this.openedMines[i][0]][this.openedMines[i][1]] == 0) f = false\n            }\n            //Если подсвечены все, и помечены верно, то победа игрока\n            if (f){\n                this.winGame()\n            }\n        }\n\n    }\n\n    //Нажатие на кнопку ПУСТО\n    isClear(){\n        //Получение ячейки\n        let xIndex = this.lastblock[0]\n        let yIndex = this.lastblock[1]\n\n        //Если мина, то ГГ\n        if (this.area[xIndex][yIndex] == 1){\n            this.filedGame()\n        //Если пустоя, то открываем ее\n        }else if (this.area[xIndex][yIndex] == 0 || this.areaOpen[xIndex][yIndex] == 3){\n            //Если ранее ячейка была подсвечена как мина\n            if (this.areaOpen[xIndex][yIndex] == 3){\n                for (let i = 0; i< this.openedMines.length; i++){\n                    //удаляем информацию о пометке\n                    if (this.openedMines[i][0] == xIndex && this.openedMines[i][1] == yIndex){\n                        this.openedMines.splice(i,1)\n                    }\n                }\n            }\n            //Открываем эту ячейку\n            this.openBlock(xIndex,yIndex)\n            //Меняем кол-во очков\n            this.score --\n        }\n        //Подсчитываем кол-во открытых пустых клеток\n        let cnt = 0\n        for (let i = 0; i<this.areaSize; i++){\n            for ( let j = 0; j < this.areaSize; j++){\n                if (this.areaOpen[i][j] == 2 )\n                    cnt ++\n            }\n        }\n        //Если все чистые открыты, то победа игрока\n        if (cnt == this.areaSize*this.areaSize-this.areaSize)\n            this.winGame()\n        //Выводим кол-во очков на экран\n        document.getElementById(\"scores\").innerHTML = this.score\n    }\n\n    //Проверка ячейки на наличие мин\n    getMinesInBlock(x,y){\n        //Проаерка на границы поля\n        if (x<0 || y<0 || x>=this.areaSize || y >= this.areaSize) return 0\n        //Если мина, то 1\n        else if (this.area[x][y] == 1) return 1\n        else return 0\n    }\n\n    //Кол-во мин вокруг клетки\n    getMinesAround(x,y){\n        let cnt = 0 // Кол-во мин\n        \n        //Перебор ячеек вокруг\n        cnt += this.getMinesInBlock(x+1,y-1)\n        cnt += this.getMinesInBlock(x+1,y)\n        cnt += this.getMinesInBlock(x+1,y+1)\n        cnt += this.getMinesInBlock(x,y-1)\n        cnt += this.getMinesInBlock(x,y+1)\n        cnt += this.getMinesInBlock(x-1,y-1)\n        cnt += this.getMinesInBlock(x-1,y)\n        cnt += this.getMinesInBlock(x-1,y+1)\n        //Возвращаем количество мин\n        return(cnt)\n    }\n\n    //ОТкрытие ячейки\n    openBlock(xIndex,yIndex){\n        //Проверка на границы поля\n        if (xIndex<0 || yIndex < 0 || xIndex >= this.areaSize || yIndex >= this.areaSize)\n        return(0)\n\n        //помечаем как открытую\n        this.areaOpen[xIndex][yIndex] = 2\n\n        //левый верхний угол ячейки\n        let xPos = this.getPosByIndex(xIndex)\n        let yPos = this.getPosByIndex(yIndex)\n\n        //Закрашиваем как открытую\n        this.ctx.fillStyle=\"#5E5E5E\";\n        this.ctx.fillRect(xPos,yPos, this.step, this.step)\n        \n        //Если вокруг мин нет, открываем ячейки\n        if (this.getMinesAround(xIndex,yIndex) == 0 ){\n            //по очереди открываем ячейки вор=круг, try-catch ловит выход за пределы поля\n            try{ if (this.area[xIndex+1][yIndex+1] == 0 && this.areaOpen[xIndex+1][yIndex+1] != 2) this.openBlock(xIndex+1,yIndex+1)} catch(e){}\n            try{ if (this.area[xIndex+1][yIndex] == 0   && this.areaOpen[xIndex+1][yIndex+1] != 2) this.openBlock(xIndex+1,yIndex)} catch(e){}\n            try{ if (this.area[xIndex+1][yIndex-1] == 0 && this.areaOpen[xIndex+1][yIndex-1] != 2) this.openBlock(xIndex+1,yIndex-1)} catch(e){}\n            try{ if (this.area[xIndex][yIndex+1] == 0   && this.areaOpen[xIndex][yIndex+1] != 2) this.openBlock(xIndex,yIndex+1)} catch(e){}\n            try{ if (this.area[xIndex][yIndex-1] == 0   && this.areaOpen[xIndex][yIndex-1] != 2) this.openBlock(xIndex,yIndex-1)} catch(e){}\n            try{ if (this.area[xIndex-1][yIndex+1] == 0 && this.areaOpen[xIndex-1][yIndex+1] != 2) this.openBlock(xIndex-1,yIndex+1)} catch(e){}\n            try{ if (this.area[xIndex-1][yIndex] == 0   && this.areaOpen[xIndex-1][yIndex] != 2) this.openBlock(xIndex-1,yIndex)} catch(e){}\n            try{ if (this.area[xIndex-1][yIndex-1] == 0 && this.areaOpen[xIndex-1][yIndex-1] != 2) this.openBlock(xIndex-1,yIndex-1)} catch(e){}\n\n        } else{\n            //Если есть мины вокруг, пишем их количество\n            this.ctx.fillStyle = 'whitesmoke'\n            this.ctx.font = \"bold \" + Math.floor(this.step/1.5) + \"pt sans-serif\"\n            this.ctx.textBaseline = \"center\"\n            this.ctx.fillText(this.getMinesAround(xIndex,yIndex),xPos+this.step/4,yPos+this.step/1.1)\n        }\n        \n    }\n\n    //Конец игры, победа\n    winGame(){\n        this.ctx.fillStyle=\"green\";\n        this.ctx.fillRect(0,0,this.canvSize,this.canvSize);\n        clearInterval(this.timer)\n        //WIP\n    }\n\n    //Проигрыш\n    filedGame(){\n        this.ctx.fillStyle=\"darkred\";\n        this.ctx.fillRect(0,0,this.canvSize,this.canvSize);\n        clearInterval(this.timer)\n        //WIP\n    }\n    \n    render(){\n        return(\n            <Panel id={this.props.id}>\n                <PanelHeader>\n                    Сапер\n                </PanelHeader>\n                <div>\n                    <div className=\"topMenu\" >\n                        <div id=\"scores\">{this.score}</div>\n                        <div id=\"time\">00:00</div>\n                    </div>\n                    <div className=\"gameContainer\">\n                        <canvas id=\"canvas\" ref=\"canvas\" width={this.canvSize} height={this.canvSize} />\n                    </div>\n                    <div className=\"buttonContainer\">\n                        <div onClick={this.isMine}>\n                            Мина\n                        </div>\n                        <div onClick={this.isClear}>\n                            Пусто\n                        </div>\n                    </div>\n                    <div className=\"backBtn\" onClick={this.props.go} data-to=\"home\">Домой</div>\n                </div>\n            </Panel>\n        )\n    }\n}\n\nexport default Playarea","import React from 'react';\nimport './App.css';\nimport Home from './Pannels/Home'\n\nimport connect from '@vkontakte/vkui-connect';\n\nimport { View } from '@vkontakte/vkui';\nimport '@vkontakte/vkui/dist/vkui.css';\nimport Playarea from './Components/Playarea';\n\n\nclass App extends React.Component {\n\n  constructor(props) {\n\t\tsuper(props);\n\n\t\tthis.state = {\n\t\t\tactivePanel: 'home',\n\t\t\tfetchedUser: null,\n\t\t};\n  }\n\n  componentDidMount() {\n    connect.send(\"VKWebAppInit\", {}); \n    \n\t\tconnect.subscribe((e) => {\n\t\t\tswitch (e.detail.type) {\n\t\t\t\tcase 'VKWebAppGetUserInfoResult':\n\t\t\t\t\tthis.setState({ fetchedUser: e.detail.data });\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log(e.detail.type);\n\t\t\t}\n\t\t});\n\t\tconnect.send('VKWebAppGetUserInfo', {});\n\t}\n  \n  go = (e) => {\n    this.setState({ activePanel: e.currentTarget.dataset.to })\n    console.log( e.currentTarget.dataset.to )\n  };\n  \n  render(){\n    return (\n    <View activePanel={this.state.activePanel}>\n\t\t\t\t<Home id=\"home\" fetchedUser={this.state.fetchedUser} go={this.go} publish={this.publish} joinToGroup={this.joinToGroup} />\n        <Playarea id=\"play\" go={this.go} />\n    </View>\n    );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n//import './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}